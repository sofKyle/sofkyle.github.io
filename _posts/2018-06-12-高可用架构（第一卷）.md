---
layout: post
title: 高可用架构（第一卷）
tags: [阅读, ]

---

<img src="https://img11.360buyimg.com/n1/jfs/t8338/175/2079290726/82502/b8b7261a/59c4c4bcN8c6318a1.jpg" />

首先，感谢公司建立的产研书吧，让产品和研发部门的小伙伴能够有更好的机会读一些好书，提升自己专业技能的同时，也让我们时刻保持向上学习的动力。此外，感谢HRBP小伙伴，让我有机会在阅读之后，发表一些个人的拙见。

我觉得读的书，从个人目的上可以大致分为两类：一类是用以解决当下的困惑，另一类则是用以开拓眼界。开始我想阅读这本《高可用架构》的时候，我是抱着后一种目的的。我希望能从这本书中汲取些比较实用的架构思想，用以帮助自己找到一些灵感去开拓成长为架构师的路。

这本书是个合集，它辑录了很多知名互联网公司专家的技术分享与交流。从日志系统、IM系统的基本架构，到高可用架构、分布式系统的实践，以及容器、大数据相关的架构设计均有涉猎。书中大大小小50来个架构案例，如果没有足够多的知识储备、亲手实践过其中的某一部分内容，是无法体会其中的精髓的。

在这里，我对我个人所感兴趣的点进行一些展开。在讲雪球的IM系统架构的时候，文中介绍到，雪球的IM系统通过Netty+自定义网络协议的方式进行消息的网络传输，然后客户端用Akka做消息同步。接下来我就稍稍分享下我对Akka这个框架的理解。

Akka是帮助构建高并发、分布式和具有容错性的事件驱动应用程序的工具包。它包含Java和Scala两种API。Akka的核心原理是基于Actor模型的。

那何谓Actor模型呢？在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态是由它自己维护的，Actor与Actor之间通过消息传递来进行状态修改。Actor由状态(state)、行为(Behavior)和邮箱(mailBox)三部分组成：
+ 状态(state)：Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题
+ 行为(Behavior)：行为指定的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态
+ 邮箱(mailBox)：邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送方Actor消息，接受方Actor从邮箱队列中获取消息

【图片：actor工作流程】

为了更好地理解Actor模型与Akka的应用，在这里，我分别用传统Java内部锁机制与Akka来实现“转账”功能。

首先，对于单个账户来讲，要保证扣款与入账操作的原子性，扣款、入账都用内部锁作同步：
``` java
public class Account {
	private int amount;
	public synchronized void deduct(int amount) {
		this.amount += amount;
	}
	public synchronized void add(int amount) {
		this.amount -= amount;
	}
}
```

然后， 在执行转账操作的时候，把两个账户都加上锁：
``` java
public void transfer(Account from, Account to, int amount) {
	synchronized(from) {
		synchronized(to) {
			from.deduct(amount);
			to.add(amount);
		}
	}
}
```

现在，我们该加锁的地方都加了，但是，这样的程序还是有问题的。假设线程1在执行账户A给账户B转账操作的时候，线程1已经抢占了账户A的锁，而另外有一线程2执行的是账户B给账户A转账的操作，且抢占到了账户B的锁。此时线程1、2都渴望抢夺到已经被对方抢占的锁，于是就发生了死锁。

解决的方案也是有的，可以给账户排序，加锁的时候按照账户顺序来抢占锁，这样便破坏了死锁必要条件中的“循环等待条件”，预防了死锁。


介绍百姓网的亿级规模Elasticsearch优化实战的时候，选择G1还是CMS作为JVM的垃圾回收器，如何设置JVM参数，这些都有讲究。我还了解到了JVM 32G现象：当JVM堆大小超过32G时，哪怕用更多的内存，效果都不如31G。这些需要讲究的地方，如果没有充足的实践，是没法得到结论的。如果没有充足的实践，也不足以对技术有更深刻的理解。除此之外，书中还有章节介绍NoSQL的发展历史。在了解到了NoSQL的发展史之后，我丝毫不会再去疑惑“NoSQL是否会最终替代RDB”这样的问题。NoSQL和RDB都有各自适合的场景，我觉得学会根据现实状况做取舍是成长为架构师的第一步。

总而言之，书中所包含内容颇丰，具体涉及到架构案例的章节，也有足够的深度与广度。所以我觉得这本书不适合用来“找灵感”，倒更适合于在具体实践某种架构方案的时候，掌握一些他人已实践过的可能性。

下面说点题外话。《极客与团队》一书里面提到，程序员之间其实是需要多多交流的，因为单打独斗不光是增加了自己失败的风险，而且浪费了自己成长的可能性。因为我们无法知道，我们自己选的路是不是对的。所以，我们要适当的把自己的问题暴露出来。我希望能有更多小伙伴参与到书吧的分享活动中来，一起来分享自己的学习、读书心得。

最后的最后，让我用《高可用架构》里面的一碗毒鸡汤来结束我的这次分享，与诸君共勉：
+ 不要奢望其他人会写出高质量的代码。
+ 不要以为自己写出来的是高质量的代码。