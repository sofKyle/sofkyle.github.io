---
layout: post
title: Netty的组件和设计
tags: [Netty, ]

---


### Channel、EventLoop和ChannelFuture
可以认为有这样的抽象关系：
+ Channel——Socket
+ EventLoop——控制流、多线程处理、并发
+ ChannelFuture——异步通知

#### Channel接口
基本的I/O操作依赖于底层网络传输所提供的原语。在基于Java的网络编程中，其基本的构造是class Socket。Netty的Channel接口所提供的API，大大地降低了直接使用Socket类的复杂性。此外，Channel也拥有许多预定义的、专门化实现的广泛类层次结构的根。



#### EventLoop接口
EventLoop定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事件。下图说明了Channel、EventLoop、Thread以及EventLoopGroup之间的关系：

【图片】

简要说来：
+ 一个EventLoopGroup包含一个或多个EventLoop
+ 一个EventLoop在它的生命周期内只和Thread绑定
+ 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理
+ 一个Channel在它的生命周期内只注册于一个EventLoop
+ 一个EventLoop可能会被分配给一个或多个Channel



#### ChannelFuture接口
Netty中所有的I/O操作都是异步的，ChannelFuture接口的addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。



### ChannelHandler和ChannelPipeline

#### ChannelHandler接口
从应用程序开发人员的角度来看，Netty的主要组件是ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。



#### ChannelPipeline接口
ChannelPipeline提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的API。当Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。

ChannelHandler安装到ChannelPipeline中的过程如下所示：

+ 一个ChannelInitializer的实现被注册到了ServerBootstrap中
+ 当ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler
+ ChannelInitializer将它自己从ChannelPipeline中移除