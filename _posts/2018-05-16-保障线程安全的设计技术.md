---
layout: post
title: 保障线程安全的设计技术
tags: [Java多线程, ]

---

### 无状态对象
**对象**就是操作和数据的封装。对象所包含的数据就被称为该对象的**状态**，它包括存储在实例变量或者静态变量之中的数据。相应地，实例变量、静态变量也被称为**状态变量**。

如果一个类的同一个实例被多个线程共享并不会使得这些线程存在共享状态，那么这个类及其任意一个实例就被称为**无状态对象**。

反之，如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为**有状态对象**。

所谓的**无状态对象**就是这样一种办法：一个线程执行无状态对象的任意一个方法来完成某个计算的时候，该计算的瞬时状态（中间结果）仅体现在局部变量或只有当前执行的线程能够访问的对象的状态上。

因此，一个线程执行无状态对象的任何方法都不会对访问该无状态对象的其他线程产生任何干扰作用。这些线程在执行该对象的任何方法的时候都无须使用同步机制。



### 不可变对象
**不可变对象**是指一经创建其状态就保持不变的对象。

一个严格意义上的不可变对象要同时满足以下所有条件：
+ 类本身使用**final**修饰：这是为了防止通过创建子类来改变其定义的行为。
+ 所有字段都是用**final**修饰：在多线程环境下保证了被修饰字段的初始化安全，即final修饰的字段在对其他线程可见时，它必定是初始化完成的。
+ 对象在初始化过程中没有逃逸：防止其他类（如该类的内部匿名类）在对象初始化过程中修改其状态。
+ 任何字段若引用了其他状态可变的对象（如集合、数组等），则这些字段必须是**private**修饰的，并且这些字段值不能对外暴露。



### 线程特有对象：ThreadLocal&lt;T&gt;
对于一个非线程安全对象，每个线程都创建一个该对象的实例，各个线程仅访问各自创建的实例，且一个线程不能访问另外一个线程创建的对象实例。这种对象我们称之为：**线程特有对象（Thread Specific Object，TSO）**，相应的线程就被称为该线程特有对象的**持有线程**。

**ThreadLocal&lt;T&gt;**类相当于线程访问其线程特有对象的代理（Proxy），即各个线程通过这个对象可以创建并访问各自的线程特有对象，其类型参数T指定了相应线程特有对象的类型。

####线程特有对象可能导致的问题及其规避
+ **退化与数据错乱：**由于线程和任务之间可以是一对多的关系，即一个线程可以先后执行多个任务，因此线程特有对象就相当于一个线程所执行的多个任务之间的共享对象。如果线程对象是个有状态的对象且其状态会随着相应线程所执行的任务而改变，那么这个线程所执行的下一个任务可能“看到”来自前一个任务的数据，而这个数据可能与该任务并不匹配，从而导致数据错乱。
> **解决方案：**需要确保每个任务的处理逻辑被执行前相应的线程特有对象不受前一个任务的影响，我们可以通过在任务处理逻辑开始前为线程局部变量重新关联一个线程特有对象或者重置线程特有对象的状态来实现。

例如：
```java
public abstract class XAbstractTask implements Runnable {
    static ThreadLocal<HashMap<String, String>> configHolder = new ThreadLocal<HashMap<String, String>>() { 
        protected HashMap<String, String> initialValue() {
            return new HashMap<String, String>();
        }
    };
    
    // 任务逻辑开始前执行的方法
    protected void preRun() {
        // 清空线程特有对象实例
        configHolder.get().clear();
    }

    // 任务逻辑完毕后执行的方法
    protected void postRun() {
        // TODO:
    }
    
    // 任务逻辑所在的方法
    protected abstract void doRun();
    
    @Override
    public final void run(){
        try {
            preRun();
            doRun();
        } finally{
            postRun();
        }
    }
}
```



### 并发集合
从JDK1.5开始，java.util.concurrent包中引入了一些线程安全的集合对象，它们被称为**并发集合**。这些对象通常可以作为同步集合的替代品，它们与常用的非线程安全集合对象之间的对应关系如表所示：

非线程安全对象 | 并发集合类 | 共同接口 | 遍历实现方式
:-: | :-: | :-: | :-:
ArrayList | CopyOnWriteArrayList | List | 快照
LinkedList | ConcurrentLinkedQueue | Queue | 准实时
HashSet | CopyOnWriteArrayList | Set | 快照
HashMap | ConcurrentHashMap | Map | 准实时
TreeSet | ConcurrentSkipListSet | SortedSet | 准实时
TreeMap | ConcurrentSkipListMap | SortedMap | 准实时

并发集合对象自身就支持对其进行线程安全的遍历操作。
