---
layout: post
title: JAVA核心
tags: [面试题集, ]

---

#### 1、hashCode相等的两个对象一定相等吗？equals呢？相反呢？
**闭卷：**
> hashCode与对象在物理内存上的地址相关，是其物理地址经过特定计算后得到的标识码，可能会出现冲突，所以hashCode相等两个对象不一定相等。
> 
> 两个对象equals相等时，首先必须hashCode相等，然后必须值相等，所以equals相等时，两个对象一定是相等的。
> 
> 反过来，相等的两个对象，hashCode和equals都是相等的。

**开卷：**
> hashCode()主要运用在Hash表数据结构（如HashMap）中，按照Object中的规约，在重写equals()时，最好重写hashCode()。
> 
> equals()相等时，hashCode()一定相等，但由于Hash冲突，可能惠出现equals()不等但hashCode()仍然相等的情况。

**整理：**
> equals()和hashCode()是两个独立的方法，本身之间并没有什么对等关系。
> 
> 但为了在Hash表数据结构中正确使用，Object类的作者在hashCode()方法的注释中与开发者协定了如下规约：
> 
> 当两个对象equals()相等，hashCode()也一定返回相同的整数。
> 
> hashCode()的默认实现，是将对象的内部地址转化为整数。

#### 2、介绍一下集合框架。
**闭卷：**
> Java中集合类都是从继承Collection接口开始的。平时用的比较多的有List、Map。List其下主要有ArrayList、LinkedList这两种实现，Map的主要实现有HashMap。
> 
> ArrayList其底部的数据结构实现其实就相当于数组，数组的初始容量为10，当数组容量满时，将其容量扩大0.5倍。
> 
> LinkedList其数据结构实现相当于链表，每次新增值时新增一个节点。
> 
> HashMap的初始容量为16，当容量快满时，将其容量扩大到2倍。其数据结构相当于Hash列表，用拉链法来解决Hash冲突问题。

**开卷：**
> 在集合框架的类继承体系中，最顶层有两个接口：
> 
> + Collection表示一组纯数据
>
> + Map表示一组key-value对

**整理：**
> 

#### 3、HashMap、HashTable底层实现有什么区别？
**闭卷：**
> HashMap是线程不安全的，它的增、删、改、查是开放的。而HashTable的在进行修改时，实现了粗粒度的内部锁，所以是线程安全的。

**开卷：**
> 

**整理：**
> 

#### 4、HashMap和TreeMap什么区别？底层数据结构是什么？
**闭卷：**
> HashMap是无序的，通过Hash列表来实现数据的Key-Value索引。而TreeMap是有序的，其底层数据结构是红黑树。

**开卷：**
> 

**整理：**
> 

#### 5、线程池都有什么参数？底层如何实现？
**闭卷：**
> CoreSize、MaxSize、时间单位

**开卷：**
> 

**整理：**
> 

#### 6、synchronized和Lock有什么区别？
**闭卷：**
> synchronized称为内部锁，Lock称为显示锁。
> 
> 在使用方法上，synchronized是通过抢夺引导锁，互斥执行锁所限定的方法或者代码块，内部锁是不可重入的。
> 
> Lock必须成对的使用lock()与release()来加锁与释放锁，可以实现不可重入锁，也可以实现可重入锁。

**开卷：**
>

**整理：**
> 

#### 7、ThreadLocal是什么？底层如何实现？写一个例子。
**闭卷：**
> ThreadLocal是线程的本地变量，当声明一个ThreadLocal对象时，每个线程都将有这个对象的副本。
>
> 其主要实现原理为：内部维护一个ThreadLocalMap（其本质就是一个Map），以当前线程为Map的Key值。这样，每次取变量值的时候，都是通过传入当前线程对象来获取变量值。

**开卷：**
> 

**整理：**
> 

#### 8、说明下volitile的工作原理。
**闭卷：**
> volitle是通过设置内存屏障，保证变量的可见性。

**开卷：**
> 

**整理：**
> 

#### 9、简述下CAS，说说它是如何实现的。
**闭卷：**
> Compare And Swap。用一组原子操作，实现对变量的互斥访问。包括两个步骤，一、比较，比较值是否改变；二、替换，如果值已改变就进行替换，未改变就不进行替换。
> 

**开卷：**
> 

**整理：**
> 

#### 10、请用4种方法写一个单例模式。
**闭卷：**
> **一、线程不安全**
```java
public class SampleOne {
	private static SampleOne instance;

	public static SampleOne getInstance() {
		if (instance == null) {
			instance = new SampleOne();
		}
		return instance;
	}
}
```

> **二、加同步锁，线程安全但效率低**
```java
public class SampleTwo {
	private static SampleTwo instance;

	public synchronized static SampleTwo getInstance() {
		if (instance == null) {
			instance = new SampleTwo();
		}
		return instance;
	}
}
```


**开卷：**
> 

**整理：**
> 