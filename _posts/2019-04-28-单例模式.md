---
layout: post
title: 单例模式
tags: [设计模式, ]

---

### 一、线程不安全
```java
public class SampleOne {
	private static SampleOne instance;

	public static SampleOne getInstance() {
		if (instance == null) {
			instance = new SampleOne();
		}
		return instance;
	}
}
```

### 二、加同步锁，线程安全但效率低
```java
public class SampleTwo {
	private static SampleTwo instance;

	public synchronized static SampleTwo getInstance() {
		if (instance == null) {
			instance = new SampleTwo();
		}
		return instance;
	}
}
```

### 三、双检锁（DCL）
```java
public class SampleThree {
	private static volatile SampleThree instance;// 语句1

	public static SampleThree getInstance() {
		if (instance == null) {// 语句2
            synchronized(SampleThree.class) {
                if (instance == null) {
                    instance = new SampleThree();// 语句3
                }
            }
        }
        return instance;
    }
}
```
> TIPS:  
> 语句1处，加上**volatile**才是正确的双检锁。这是因为语句3可能存在指令重排序。  

对于 
```java
instance = new SampleThree();
```
这个语句来说，在jvm里面正确的执行分为三步：  
+ 1.在堆内开辟内存空间；  
+ 2.初始化SampleThree中的属性；  
+ 3.将instance指向开辟的内存。  
其中2、3步因为没有严格的“happen-before”原则，故存在指令重排的可能，3和2的顺序将可能被调换。那么，就有可能线程A已经将instance指向了新开辟的内存，但是其内部的属性还没有初始化。假设另有一线程B到了语句2的位置，此时instance已经不为null，那么它将直接返回属性未被初始化的instance，从而导致获取到一个线程不安全的对象。

### 四、基于类加载机制
这一类方法，主要是利用类加载机制中，静态变量于解析阶段初始化，此时底层实际也是通过AQS互斥地初始变量。
```java
public class SampleFour {
	private static final SampleFour instance = new SampleFour();

	public static SampleFour getInstance() {
        return instance;
    }
}
```

### 五、CAS
```java
public class SampleFive {
	private static final AtomicReference<SampleFive> instance = new AtomicReference<>();

	public static SampleFive getInstance() {
        for (;;) {
            if (instance.get() == null) {
                SampleFive newInstance = new SampleFive();
                instance.compareAndSet(null, newInstance);
            }
            return instance.get();
        }
    }
}
```