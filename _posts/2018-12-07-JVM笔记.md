---
layout: post
title: JVM笔记
tags: [JVM, ]

---

+ 多线程共享的内存区域主要存放两类数据：类数据和类实例（也就是对象）。对象数据存放在堆（Heap）中，类数据存放在方区（Method Area）中。类数据包括字段和方法信息、方法的字节码、运行时常量池，等等。

+ 每个线程都有自己的PC寄存器和JAVA虚拟机栈。JAVA虚拟机栈又由栈帧构成，帧中保存方法执行的状态，包括局部变量表和操作数栈等。在任意时刻，某一线程肯定是在执行某个方法，这个方法叫做该线程的当前方法。执行该方法的帧叫做线程的当前帧。声明该方法的类叫做当前类。如果当前方法是JAVA方法，则PC寄存器中存放正在执行的JAVA虚拟机指令的地址，否则，当前方法是本地方法，PC寄存器中的值没有明确定义。

+ 如果Java虚拟机栈有大小限制，且执行线程所需的栈空间超出了这个限制，会导致StackOverflowError异常抛出。如果Java虚拟机栈可以动态扩展，但是内存已经耗尽，会导致OutOfMemoryError异常抛出。

<img src="https://github.com/sofkyle/sofkyle.github.io/blob/master/_posts/image/jvm/运行时数据区.png?raw=true" />

+ Java虚拟机使用的是变长指令。每条指令都以一个单字节的操作码（opcode）开头，这就是**字节码**名称的由来。由于只使用一字节表示操作码，显而易见，Java虚拟机最多只能支持256（28）条指令。到第八版为止，Java虚拟机规范已经定义了205条指令，操作码分别是0（0x00）到202（0xCA）、254（0xFE）和255（0xFF）。这205条指令构成了Java虚拟机的指令集（instructionset）。和汇编语言类似，为了便于记忆，Java虚拟机规范给每个操作码都指定了一个助记符（mnemonic）。比如操作码是0x00这条指令，因为它什么也不做，所以它的助记符是nop（nooperation）。

+ 操作数栈和局部变量表只存放数据的值，并不记录数据类型。结果就是：指令必须知道自己在操作什么类型的数据。这一点也直接反映在了操作码的助记符上。例如，iadd指令就是对int值进行加法操作；dstore指令把操作数栈顶的double值弹出，存储到局部变量表中；areturn从方法中返回引用值。也就是说，如果某类指令可以操作不同类型的变量，则助记符的第一个字母表示变量类型。