---
layout: post
title: Java线程间协作（二）
tags: [Java多线程, ]

---


### 倒计时协调器：CountDownLatch

CountDownLatch可以用来实现一个（或者多个）线程等待其他线程完成一组特定的操作之后才继续运行。这组特定的操作被称为**先决操作**。

#### CountDownLatch实现原理

CountDownLatch内部会维护一个用于表示未完成的先决操作数量的计数器。
**CountDownLatch.countDown()**每被执行一次就会使相应实例的计数器值减1。
**CountDownLatch.await()**相当于一个受保护的方法，其保护条件为“计数器值为0”，此时代表所有先决操作已执行完毕。

当计数器值不为0时，CountDownLatch.await()的执行线程会被暂停，这些线程就被称为相应CountDownLatch上的等待线程。CountDownLatch.countDown()相当于一个通知方法，它会在计数器值达到0的时候唤醒实例上的所有等待线程。

> **TIPS：**当计数器的值达到0之后，该计数器的值就不再发生变化。此时，调用CountDownLatch.countDown()并不会导致异常的抛出，并且后续执行CountDownLatch.await()的线程也不会被暂停。因此，CountDownLatch的使用时**一次性**的：一个CountDownLatch实例只能够实现一次等待和唤醒。

##### CountDownLatch示例：
``` java
public class CountDownLatchExample {
    private static final CountDownLatch latch = 
     new CountDownLatch(4);
    private static int data;

    public static void main(String[] args)
     throws InterruptedException {
        Thread workerThread = new Thread(() -> {
            for(int i = 0; i < 10; i++) {
                data = i;
                latch.countDown();
                // 暂停一段时间
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ie) {
                    ie.printStackTrace();
                }
            }
        });
        workerThread.start();
        latch.await();
        System.out.println(
         String.format("It's done. data=%d", data));
    }
}
```
改程序的输出总是如下：It's done. data=4