<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>明日又天涯</title>
    <description>人间如梦，倚笑乘风凉</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 22 Apr 2018 23:38:36 +0800</pubDate>
    <lastBuildDate>Sun, 22 Apr 2018 23:38:36 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>Java线程同步机制</title>
        <description>&lt;h1 id=&quot;java线程同步机制&quot;&gt;Java线程同步机制&lt;/h1&gt;
&lt;h3 id=&quot;java锁分类&quot;&gt;Java锁分类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内部锁（Intrinsic Lock）&lt;/strong&gt;：通过synchronized关键字实现。
&lt;strong&gt;显式锁（Explicit Lock）&lt;/strong&gt;：通过java.concurrent.locks.Lock接口的实现类实现，如：java.concurrent.locks.ReentrantLock。&lt;/p&gt;

&lt;h3 id=&quot;可重入性&quot;&gt;可重入性&lt;/h3&gt;
&lt;p&gt;一个线程在其持有一个锁的时候能否再次（或者多次）申请&lt;strong&gt;该&lt;/strong&gt;锁。
如果一个线程持有一个锁的时候还能够继续成功申请该锁，则称该锁是可重入的，否则称为非可重入的。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIPS：&lt;/strong&gt;可重入锁可以被理解为一个对象，该对象包含一个计数器属性，表示相应的锁还没有被任何线程持有。每次线程获得一个可重入锁的时候，该锁的计数器值会被增加1。每次一个线程释放锁的时候，该锁的计数器属性值就会被减1。一个线程初次获得可重入锁时相应的开销相对大，因为必须与其他线程“竞争”以获得锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;内部锁&quot;&gt;内部锁&lt;/h3&gt;
&lt;h4 id=&quot;示例&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nextSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;锁句柄&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 同步块&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;锁句柄是一个对象的引用，可以填写为&lt;strong&gt;this&lt;/strong&gt;关键字，即表示以当前对象为锁句柄。锁句柄对应的监视器就被称为相应同步块的&lt;strong&gt;引导锁&lt;/strong&gt;。线程在执行临界区代码的时候必须持有该临界区的引导锁。&lt;/p&gt;

&lt;h4 id=&quot;内部锁的调度&quot;&gt;内部锁的调度&lt;/h4&gt;
&lt;p&gt;Java虚拟机会为每个内部锁分配一个&lt;strong&gt;入口集（Entry Set）&lt;/strong&gt;，用来记录等待获得相应内部锁的线程。只有一个申请者能够成为该锁的持有线程，其他申请失败者会进入&lt;strong&gt;BLOCKED&lt;/strong&gt;状态并被存入相应锁的入口集中等待。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIPS：&lt;/strong&gt;申请的锁被其持有线程释放的时候，该锁的入口集中的&lt;strong&gt;任意一个线程&lt;/strong&gt;会被Java虚拟机唤醒。Java虚拟机对内部锁的调度仅支持&lt;strong&gt;非公平调度&lt;/strong&gt;，被唤醒的等待线程即将要占用处理器运行时可能还有其他新的活跃线程与该线程抢占这个被释放锁，因此被唤醒的线程不一定就能成为该锁的持有线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;显式锁lock接口&quot;&gt;显式锁：Lock接口&lt;/h3&gt;
&lt;h4 id=&quot;示例-1&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 创建一个Lock接口实例&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 申请锁&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 同步块&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 必须释放锁&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;显式锁的调度&quot;&gt;显式锁的调度&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ReentrantLock&lt;/strong&gt;既支持非公平锁也支持公平锁。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIPS：&lt;/strong&gt;公平锁对线程的暂停和唤醒有了约束，故而增加了
上下文切换的代价。因此，公平锁适合于锁被持有的时间相对较长或者线程申请锁的平均间隔时间相对长的情形。显式锁默认使用的是非公平调度策略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;读写锁&quot;&gt;读写锁&lt;/h3&gt;
&lt;p&gt;Java中对读写锁的抽象使用的是：java.util.concurrent.locks.ReadWriteLock接口，其默认实现类是：java.util.concurrent.locks.ReentrantReadWriteLock。
ReentrantReadWriteLock所实现的读写锁是个可重入锁，并且支持&lt;strong&gt;锁的降级&lt;/strong&gt;，即支持一个线程持有写锁的情况下可以继续获得相应的读锁。&lt;/p&gt;

&lt;h3 id=&quot;内存屏障&quot;&gt;内存屏障&lt;/h3&gt;
&lt;p&gt;内存屏障是对一类仅针对内存读、写操作指令的跨处理器架构的比较底层的抽象。内存屏障是被插入到两个指令之间进行使用的，其作用是禁止编译器、处理器重排序从而保障有序性。它在指令序列中就像一堵墙，使其两侧的指令无法“穿越”它。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;font color=&quot;red&quot; face=&quot;黑体&quot;&gt;疑问点：&lt;/font&gt;
  &lt;font color=&quot;red&quot;&gt;分类：
可见性：加载屏障、存储屏障
有序性：获取屏障、释放屏障
&lt;/font&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;锁与重排序&quot;&gt;锁与重排序&lt;/h3&gt;
&lt;p&gt;与锁有关的重排序规则可以理解为指令相对于临界区的“许进不许出”。&lt;/p&gt;
&lt;h4 id=&quot;重排序规则&quot;&gt;重排序规则&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;假定只有一个临界区时：&lt;/strong&gt;
一、临界区内的操作不允许被重排序到临界区之外；
二、临界区内的操作之间允许被重排序；
三、临界区外的操作之间可以被重排序；
&lt;strong&gt;扩展到多个临界区：&lt;/strong&gt;
四、锁申请与锁释放操作不能被重排序；
五、两个锁申请操作不能被重排序；
六、两个锁释放操作不能被重排序。
七、临界区外的操作可以被重排到临界区之内。&lt;/p&gt;

&lt;h3 id=&quot;轻量级同步机制volatile关键字&quot;&gt;轻量级同步机制：volatile关键字&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;volatile变量不会被编译器分配到寄存器进行存储，对volatile变量的读写操作都是内存访问操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;volatile原子性&quot;&gt;Volatile原子性&lt;/h4&gt;
&lt;p&gt;在原子性方面它仅能保障对所修饰变量的读写原子性，volatile关键字的使用不会引起上下文切换。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIPS：&lt;/strong&gt;在Java语言中，对long型和double型以外的任何类型的写操作都是原子操作，通过使用volatile关键字可以保障long/double型变量写操作的原子性。&lt;/p&gt;
  &lt;h4 id=&quot;volatile有序性&quot;&gt;Volatile有序性&lt;/h4&gt;
  &lt;p&gt;禁止了如下重排序：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;写volatile变量操作与该操作之前的任何读、写操作不会被重排序；&lt;/li&gt;
    &lt;li&gt;读volatile变量操作与该操作之后的任何读、写操作不会被重排序。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;cas与原子变量&quot;&gt;CAS与原子变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CAS(Compare and Swap)&lt;/strong&gt;是对一种处理器指令的称呼。
CAS只是保障了共享变量更新这个操作的原子性，它并不保障可见性。&lt;/p&gt;

&lt;h4 id=&quot;原子操作工具原子变量类&quot;&gt;原子操作工具：原子变量类&lt;/h4&gt;
&lt;p&gt;原子变量类（Atomics）是基于CAS实现的能够保障对共享变量进行read-modify-write更新操作的原子性和可见性的一组工具类。
分组 | &lt;center&gt;类&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;基础数据类型&lt;/td&gt;
          &lt;td&gt;AtomicInteger、AtomiceLong、AtomicBoolean&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;数组型&lt;/td&gt;
          &lt;td&gt;AtomicIntegerArray、AtomictLongArray、AtomicReferenceArray&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;字段更新器&lt;/td&gt;
          &lt;td&gt;AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;引用型&lt;/td&gt;
          &lt;td&gt;AtomicReference、AtomicStampedReference、AtomicMarkableReference&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;aba问题&quot;&gt;ABA问题&lt;/h4&gt;
&lt;p&gt;对于共享变量V，当前线程看到它的值为A的那一刻，其他线程已经将其值更新为B，接着在当前线程执行CAS的时候该变量的值又被其他线程更新为A，那么此时我们是否认为V的值没有被其他线程更新过呢？或者说这种结果是否可以接受呢？
规避ABA问题的方案：为变量的更新引入版本号。&lt;/p&gt;

&lt;h3 id=&quot;对象的发布&quot;&gt;对象的发布&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对象发布&lt;/strong&gt;是指使对象能够被其作用域之外的线程访问。&lt;/p&gt;

&lt;h4 id=&quot;重识static与final&quot;&gt;重识static与final&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;多线程环境中，&lt;strong&gt;static&lt;/strong&gt;关键字能保障线程正确读取到相应字段的初始值，但无法保障正确读取到更新值。&lt;/li&gt;
  &lt;li&gt;由于重排序的作用，一个线程读取到一个对象的引用时，该对象可能尚未初始化完毕，在多线程环境中，&lt;strong&gt;final&lt;/strong&gt;保证字段发布到其他线程的时候都是初始化完毕的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全发布与逸出&quot;&gt;安全发布与逸出&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安全发布&lt;/strong&gt;就是指对象以一种线程安全的方式被发布。
&lt;strong&gt;逸出&lt;/strong&gt;是指一个对象的发布出现我们不期望的结果或者对象发布本身不是我们所期望的时候。&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/18/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/18/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Java多线程</category>
        
        
      </item>
    
      <item>
        <title>Markdown入门（第一章）</title>
        <description>&lt;h2 id=&quot;markdown标题设置&quot;&gt;Markdown标题设置&lt;/h2&gt;

&lt;p&gt;在html中，我们用h1、h2这样的标签来设置标题，实质上就是对某一些文字增加了一些样式。&lt;/p&gt;

&lt;p&gt;Markdown也是一样的，有特定的样式来标明标题。
Markdown有6个标识标题的等级，分别是：#、##、###、####、#####、######&lt;/p&gt;

&lt;p&gt;效果分别如下：&lt;/p&gt;

&lt;h1 id=&quot;标题一&quot;&gt;标题一&lt;/h1&gt;

&lt;h2 id=&quot;标题二&quot;&gt;标题二&lt;/h2&gt;

&lt;h3 id=&quot;标题三&quot;&gt;标题三&lt;/h3&gt;

&lt;h4 id=&quot;标题四&quot;&gt;标题四&lt;/h4&gt;

&lt;h5 id=&quot;标题五&quot;&gt;标题五&lt;/h5&gt;

&lt;h6 id=&quot;标题六&quot;&gt;标题六&lt;/h6&gt;

&lt;p&gt;此外，还有一种方式，就是加下划线的方式。
包括两种：
— 几个连续的减号
=== 几个连续的等于号&lt;/p&gt;

&lt;p&gt;通过把上述符号加在需要设置为标题的文字下方，以实现标题设置，效果分别如下：&lt;/p&gt;

&lt;h2 id=&quot;标题二-1&quot;&gt;标题二&lt;/h2&gt;

&lt;h1 id=&quot;标题一-1&quot;&gt;标题一&lt;/h1&gt;
</description>
        <pubDate>Sun, 03 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/07/03/Markdown%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/07/03/Markdown%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
        
        <category>Markdown</category>
        
        
      </item>
    
      <item>
        <title>Markdown入门（序章）</title>
        <description>&lt;h2 id=&quot;markdown&quot;&gt;Markdown&lt;/h2&gt;

&lt;p&gt;最开始接触Markdown，是为了利用Github Webpages搭建自己的技术博客。&lt;/p&gt;

&lt;p&gt;把个人博客搭在Github Webpages上，既是为了图个方便，省去了自己搭服务器的麻烦，也是为了让自己能够有东西往github上提交，以实现自己一个小小的心愿————github 100连击。^_^!&lt;/p&gt;

&lt;p&gt;在接触后，发现了它一些很强大的特点。&lt;/p&gt;

&lt;p&gt;以下是我引用的一些百度上对Markdown的描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。
Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。
世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。
Markdown可以用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而看了这些，可能还是会让人朦胧晕眩，Markdown到底是干什么的呢？它用来解决些什么问题？又该如何使用？这些都是我希望通过这个教程能让大家明白的。&lt;/p&gt;

&lt;p&gt;对于Markdown的应用场景，首先可以举一个例子：
github的项目描述文件”README.MD”便是用Markdown来写的，它让我们在描述我们项目的时候，可以增加更多类型的文档元素，如控制文章标题段落样式、引用图片、导入超级链接等。使我们的描述更加生动。有点儿类似用html写一个静态网页。&lt;/p&gt;

&lt;p&gt;废话不多说，实践最重要。&lt;/p&gt;

&lt;p&gt;最后附上Markdown的文档站&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;前往链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/07/02/Markdown%E5%85%A5%E9%97%A8-%E5%BA%8F%E7%AB%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/07/02/Markdown%E5%85%A5%E9%97%A8-%E5%BA%8F%E7%AB%A0/</guid>
        
        <category>Markdown</category>
        
        
      </item>
    
  </channel>
</rss>
